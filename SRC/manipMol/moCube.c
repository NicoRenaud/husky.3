#include "../defMacro.h"
#include "../huckel/header.h"
#include "../algebra_real/algebra.h"
#include "../huckel/huckel.h"
//#include "../huckel/read_input_hkl.h"
#include "../manag_output/print_screen.h"
#include "./moCube.h"
#include <gsl_sf_legendre.h>

void moCube(double *VAL_PRP, double *VECT_PRP, int index_mo, atom *molecule, int nb_atom, int nb_orb, char *file_name, char *PARAM)
{


  int i,ik=0;
	int ix,iy,iz;
	int nX=51,nY=51,nZ=51;
  FILE *f;
	int atom_type;
	double ANG2BOHR = 1.8897161646320724;
	//double BOHR2ANG = 1.;
	double xmin = 1E6, xmax = -1E6;
	double ymin = 1E6, ymax = -1E6;
	double zmin = 1E6, zmax = -1E6;
	double X,Y,Z;
	double data;
	double border = 3.0; // in agstrom
	double RESX,RESY,RESZ;
	//double DIST;
	

	

	
  // read the atomic parameter
  read_atomic_parameters(PARAM);
  

  ///////////////////////////////////////////////////////////////////////////////
  //		WRITE THE FILE GAUSSIAN CUBE STYLE for VMD
  ///////////////////////////////////////////////////////////////////////////////

	
  // open the file
  f = fopen(file_name,"w");
  if(!f) 
  {
      printf("couldn't read %s\n",file_name);
      exit(1);
  }
	
	
  // detect which format
	fprintf(f,"Cube file generated by HUCKEL from EHMO data \n BOUYAKASHA \n");



	// determine the size of the box in angstrom
	printf("\t -- %dx%dx%d (%d) voxels \n",nX,nY,nZ,nX*nY*nZ);
	for(i=0;i<nb_atom;i++)
	{
		// minimal positions
		if(molecule[i].x < xmin)
			xmin = molecule[i].x;
		if(molecule[i].y < ymin)
			ymin = molecule[i].y;
		if(molecule[i].z < zmin)
			zmin = molecule[i].z;

		// maximal positions			
		if(molecule[i].x > xmax)
			xmax = molecule[i].x;
		if(molecule[i].y >ymax)
			ymax = molecule[i].y;
		if(molecule[i].z > zmax)
			zmax = molecule[i].z;
	}
	
	// add borders still in agstrom
	xmin -= border;
	ymin -= border;
	zmin -= border;
	
	xmax += border;
	ymax += border;
	zmax += border;
	
	/*
	xmin = -5;
	ymin = -5;
	zmin = -5;
	
	xmax = 5;
	ymax = 5;
	zmax = 5;
	*/
	
	// distance between two points in angstrom
	RESX =  (xmax-xmin)/(nX-1.);
	RESY =  (ymax-ymin)/(nY-1.);
	RESZ =  (zmax-zmin)/(nZ-1.);
	
	
	// write the box in bohr cause VMD sucks
  fprintf(f,"   %5d   % 1.6f   % 1.6f   % 1.6f\n",nb_atom,xmin*ANG2BOHR,ymin*ANG2BOHR,zmin*ANG2BOHR);
  fprintf(f,"   %5d   % 1.6f   % 1.6f   % 1.6f\n",nX,RESX*ANG2BOHR,0.0,0.0);
  fprintf(f,"   %5d   % 1.6f   % 1.6f   % 1.6f\n",nY,0.0,RESY*ANG2BOHR,0.0);
  fprintf(f,"   %5d   % 1.6f   % 1.6f   % 1.6f\n",nZ,0.0,0.0,RESZ*ANG2BOHR);
	
	
	// write the atoms
	// print the atoms
	for(i=0;i<nb_atom;i++)
	{
		atom_type = findIndex_reduced(molecule[i].atomTypeChar,PARAM);
		fprintf(f,"   %5d   % 1.6f   % 1.6f   % 1.6f   % 1.6f\n",atom_type,0.0,molecule[i].x*ANG2BOHR,molecule[i].y*ANG2BOHR,molecule[i].z*ANG2BOHR);
	}
	
	
	// compute and print the data
	for (ix=0;ix<nX;ix++)
	{
		for (iy=0;iy<nY;iy++)
		{
		 for (iz=0;iz<nZ;iz++)
		 {
				// position of the voxel in angstrom
				X = (xmin+ix*RESX);
				Y = (ymin+iy*RESY);
				Z = (zmin+iz*RESZ);
				
				// value of the MO in that voxel
				//printf("\t \t - %d/%d voxel\n",ik,nX*nY*nZ);
				ik++;
				data = compute_value_mo(VECT_PRP,index_mo,X,Y,Z,molecule,nb_atom,nb_orb,PARAM);
				fprintf(f," % 1.6e",data);
				if (iz % 6 == 5)
					 fprintf(f,"\n");
		 }
		 fprintf(f,"\n");
	  }
	}

	   
 // close file
 fclose(f);

}



////////////////////////////////////////////////////////////////////////////
// COMPUTE	the VALUE OF THE MO AT A GIVEN POINT IN SPACE
////////////////////////////////////////////////////////////////////////////

double compute_value_mo(double *VECT_PRP,int index_mo, double X, double Y, double Z, atom* molecule, int natom, int nb_orb, char *PARAM)
{


	int i,iL;
	double MO = 0;
	double *slater_coeff;
	double *qnumb;
	int index_coeff = 0;
	double coeff,orb;
	double R;
	double TETA,PHI;
	double dX,dY,dZ;
	double rad;
	int print_warning = 1;
	
	// alloc memory
  slater_coeff = calloc(4,sizeof(double));
  qnumb = calloc(4,sizeof(double));
	

	
	// for all the atoms
	for(i=0;i<natom;i++)
	{
	
		//printf("  -- %d atom\n",i);
		
		// Distance to the atom
		dX = X-molecule[i].x;
		dY = Y-molecule[i].y;
		dZ = Z-molecule[i].z;
		R = sqrtf(dX*dX + dY*dY + dZ*dZ);
		
		// angular values for shperica harmonics
		TETA = acos( dZ/R );
		PHI = atan2(dY,dX);
	
		// we get its info from the param file
		get_atom_info_all(slater_coeff, qnumb, molecule[i].atomtype, PARAM);
		//print_vect(slater_coeff,4,"ZETA");
		
		// S orbitals
		if(qnumb[0] > 0)
		{
				
				coeff = VECT_PRP[index_mo*nb_orb+index_coeff];
				orb = coeff*slater_radial(qnumb[0],0,slater_coeff[0],R)/sqrtf(4.*PI);
				MO += orb;
				index_coeff+=1;
		}
		
		// P orbitals
		if(qnumb[1] > 0)
		{
					// radial part of the function
					rad = slater_radial(qnumb[1],1,slater_coeff[1],R);
					
					// px orbitals
					coeff = VECT_PRP[index_mo*nb_orb+index_coeff];					
					MO += coeff*rad*0.5*sqrtf(3./(8.*PI))*sin(TETA)*cos(PHI);
					index_coeff+=1;
					
					
					// py orbitals
					coeff = VECT_PRP[index_mo*nb_orb+index_coeff];					
					MO += coeff*rad*0.5*sqrtf(3/(8*PI))*sin(TETA)*sin(PHI);
					index_coeff+=1;
					
					
					// pz orbitals
					coeff = VECT_PRP[index_mo*nb_orb+index_coeff];					
					MO += coeff*rad*0.5*sqrtf(3/(4*PI))*cos(TETA);
					index_coeff+=1;
		}
		
		// D orbitals
		if(qnumb[2] > 0)
		{

					// radial part of the function
					rad = slater_radial(qnumb[2],1,slater_coeff[1],R);
					
					// dxy
					coeff = VECT_PRP[index_mo*nb_orb+index_coeff];
					MO += coeff * rad * 0.5 * sqrtf(15/32/PI) * sin(TETA)*sin(TETA)*sin(2*PHI);
					index_coeff+=1;
					
					
					// dxz
					coeff = VECT_PRP[index_mo*nb_orb+index_coeff];
					MO += coeff * rad * 0.5 * sqrtf(15/8/PI) * sin(TETA)*cos(TETA)*cos(PHI);
					index_coeff+=1;
					
					// dyz
					coeff = VECT_PRP[index_mo*nb_orb+index_coeff];
					MO += coeff * rad * 0.5 * sqrtf(15/8/PI) * sin(TETA)*cos(TETA)*sin(PHI);
					index_coeff+=1;
					
					// dx2-dy2
					coeff = VECT_PRP[index_mo*nb_orb+index_coeff];
					MO += coeff * rad * 0.5 * sqrtf(15/32/PI) * sin(TETA)*sin(TETA)*cos(2*PHI);
					index_coeff+=1;
					
					
					// dz2
					coeff = VECT_PRP[index_mo*nb_orb+index_coeff];
					MO += coeff * rad *  sqrtf(5/16/PI) * (3*cos(TETA)*cos(TETA)-1);
					index_coeff+=1;
				
		}
		
		
		// F orbitals
		if(qnumb[3] > 0)
		{
				for(iL=-3;iL<=3;iL++)
				{
					if(print_warning == 1)
					{
						printf("\t -- F orbitals not yet implemented \n");
						print_warning = 0;
					}
					//coeff = VECT_PRP[index_mo*nb_orb+index_coeff];
					index_coeff+=1;
				}
		}
	
  }
	
	
	
	return MO;

}



//////////////////////////////////////////////////////////////////////////
/// Compute the radial part of a slater orbital
//////////////////////////////////////////////////////////////////////////
double slater_radial(int n, int l, double slater_coeff, double DIST)
{

	double r;
	double N = 1;
	double fact2n = factorial(2.*n);
	
	
	// compute the radial part
	//if(n>1)
	N =  powf(2.*slater_coeff,n)*sqrtf(2.*slater_coeff/fact2n);
	r =  N*powf(DIST,n-1)*expf(-slater_coeff*DIST);

	return r;
}


//////////////////////////////////////////////////////////////////////////
/// Compute the angular part of a slater orbital
//////////////////////////////////////////////////////////////////////////
double slater_harmonic(int l, int m, double TETA, double PHI)
{

	double K;
	double LP;
	double Y=0.;
	double cosTeta = cos(TETA);
	double md = (double) m;

	// prefactor
	K = sqrt((2.*l+1.)*factorial(l-abs(m))/ ( 4.*PI*factorial(l+abs(m))));

	// different cases depending on m
	if(m>0)
	{
			LP = gsl_sf_legendre_sphPlm(l,m,cosTeta);
			Y = sqrtf(2.)*cos(md*PHI)*LP;
	}
	else if(m==0)
	{
			LP = gsl_sf_legendre_sphPlm(l,0,cosTeta);
			Y = LP;
	}
	else if(m<0)
	{
		LP = gsl_sf_legendre_sphPlm(l,-m,cosTeta);
		Y = sqrtf(2.0)*sin(-md*PHI)*LP;
	}
	
	//Y = 1.0;
	return Y;

}


//////////////////////////////////////////////////////////////////////////
/// Get all the info about the atoms
// i know it s dirty
//////////////////////////////////////////////////////////////////////////

int get_atom_info_all(double *slater_coeff, double *qnumb, int index_atom, char *HUCKEL_PARAM)
{
	FILE *Fparameter;
	int count = 0;
  int j;


	//open the file containing the parameter
	Fparameter=fopen(HUCKEL_PARAM,"r");
	
	// stop reading
	int read=1;
	char atname[5];
	// define the variable to read
  int valence_electron;
	
	while(read)
	{
	
	  count++;
		//printf("%d == %d read=%d\n",count,index_atom,read);
		
		fscanf(Fparameter,"%s",atname);
		//printf("%s\n",atname);
		fscanf(Fparameter,"%d",&valence_electron);
	
		for(j=0;j<4;j++)
			fscanf(Fparameter,"%lf ",&qnumb[j]);
		
	
		for(j=0;j<4;j++)
		{
			fscanf(Fparameter,"%*f %lf %*f %*f %*f %*f", &slater_coeff[j]);
	  }

		// the coeff of the 2 and p orbitals are on coeff1
		// the coeff of the d and f orbitals are on coeff2
		//slater_coeff[0] = coeff1[0];
		//slater_coeff[1] = coeff1[1];
		//slater_coeff[2] = coeff1[2];
		//slater_coeff[3] = coeff1[3];
		
		if(count==index_atom)
		{
		 //printf("%d/%d %d %f %f %f %f\n",count,index_atom,valence_electron,slater_coeff[0],slater_coeff[1],slater_coeff[2],slater_coeff[3]);
	   read = 0;
		}
		 
    if(count > 256)
	   read = 0;
		 
	}
	fclose(Fparameter);
	return valence_electron;
}



//////////////////////////////
// compute the factorielle
//////////////////////////////
double factorial(double n)
{
 int i;
 double f = 1.;
 for(i=1;i<=n;i++)
	f*=i;
 return f;
}


